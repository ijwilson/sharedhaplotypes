---
title: "Shared Haplotypes around a mutation"
author: "Ian Wilson"
date: "30 January 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#### obtain the pedigree information for the 1000 genomes samples, both phase 1 and phase 3

```{r}
if (!dir.exists("./tmpfiles")) dir.create("./tmpfiles/")
ped_phase1 <- read.csv("ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20110521/supporting/phase1_samples_integrated_20101123.ped", header=TRUE, sep="\t", quote="")
ped_phase3 <- read.csv("ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/integrated_call_samples_v2.20130502.ALL.ped", header=TRUE, sep="\t", quote="")

download.file("ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20110521/supporting/phase1_samples_integrated_20101123.ped","tmpfiles/phase1_samples_integrated_20101123.ped")
download.file("ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/integrated_call_samples_v2.20130502.ALL.ped", "tmpfiles/integrated_call_samples_v2.20130502.ALL.ped")
```

## use tabix to get a copy of the data between positions 178404570 and 179734924 on chromosome 2

```{r, eval=FALSE}
library(Rsamtools)
url <- "ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/phase1/analysis_results/integrated_call_sets/ALL.chr2.integrated_phase1_v3.20101123.snps_indels_svs.genotypes.vcf.gz"
range <- GRanges("2", IRanges(178404570,179734924))
tb <- TabixFile(url)
countTabix(open(tb), range=range)
scanTabix(open(tb), )
```
I can't make this work so better to use the command line for this

#### phase 1 and phase 3

```
tabix -fh ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/phase1/analysis_results/integrated_call_sets/ALL.chr2.integrated_phase1_v3.20101123.snps_indels_svs.genotypes.vcf.gz 2:178404570-179734924 > tmpfiles/temporary1.vcf
tabix -fh  ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/ALL.chr2.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz 2:178404570-179734924 > tmpfiles/temporary3.vcf
```

#### phase 3

#### transform to get phased output in IMPUTE format

```
vcftools --phased --vcf tmpfiles/temporary3.vcf --IMPUTE --out tmpfiles/impute1K3 
vcftools --phased --vcf tmpfiles/temporary1.vcf --IMPUTE --out tmpfiles/impute1K1 
rm tmpfiles/temporary?.vcf 
```

Examine these positions a bit more

```{r read_positions}
positions_1K1 <- read.table("tmpfiles/impute1K1.impute.legend", header=TRUE)
positions_1K3 <- read.table("tmpfiles/impute1K3.impute.legend", header=TRUE)

positions_HMERF <- read.csv("HMERF_Haplotype.csv")
```
we have read `r nrow(positions_1K1)` positions from the phase 1 1000 genomes and `r nrow(positions_1K3)` 
from the phase 3.

Use I used python before to strip out the usable SNPs from the 1000 genomes, but I want to make the code more general 
so I use `data.table` within R.


```{r extract_positionsr}
library(data.table)
library(pander)
options(scipen=999)


## should really write a function.

data_hmerf <- fread("HMERF_Haplotype.csv", showProgress = FALSE)
setkey(data_hmerf, position)
dbfile <- "tmpfiles/impute1K3.impute.legend"
out <- "match1K3"

data_1K <- fread(dbfile, showProgress = FALSE)
data_1K[, rownum := 1:nrow(data_1K)]
setkey(data_1K, pos)
matching_positions <- data_hmerf[data_1K, nomatch=0]
fwrite(matching_positions, file = paste("tmpfiles/HMERF", out, ".csv", sep=""), showProgress = FALSE)

d <- rbind(matching_positions, data_hmerf[position==179410829], fill=TRUE)
setkey(d, position)

fwrite(
  matching_positions[,.(ID, pos=position, allele0, allele1)],
  file=paste("tmpfiles/", out, ".legend", sep=""), showProgress = FALSE
)

code <- list()
for (i in 1:nrow(matching_positions)) {
  code[[i]] <- c(matching_positions$allele0[i], matching_positions$allele1[i])
}

pander(matching_positions, caption="Present in HMERF and 1K", split.table=Inf)

missing <- data_hmerf[!(position %in% data_1K$pos)]
pander(data.table(missing), caption="Present in HMERF and missing in 1K Genomes")

all_1K <- fread("tmpfiles/impute1K3.impute.hap", showProgress = FALSE)
all_1K <- all_1K[matching_positions$rownum,]

genotypes <- matrix("", nrow=nrow(matching_positions), ncol=ncol(all_1K))
for (index in 1:nrow(matching_positions)) {
  row <- as.integer(all_1K[index, ])+1
  genotypes[index,] <- code[[index]][row]
}

fwrite(data.table(genotypes), sep=" ", col.names = FALSE, file="match1K")

outfile = open("match1K","w")

```


```{python extract_positions}
import sys
data=[a.strip().split(",") for a in open("HMERF_Haplotype.csv")]

header, data = data[0], data[1:]
outHMERF = open("HMERFmatch1K.csv","w")
outHMERF.write(",".join(h for h in header)+"\n")
## step through the positions available 
positions=dict()

for index,b in enumerate(data):
    positions[int(b[0])] = (index,b)

infile = open("impute1K.impute.legend")
header=infile.readline()
outlegend = open("match1K.legend","w")
outlegend.write(header)

seen=set()
indices=dict()
print "=============================\nSNPs present in both"
print "-----------------------------"
for linenum,a in enumerate(infile):
    ID,pos,allele0,allele1 = a.strip().split()
    if int(pos) in positions:
        outlegend.write(a)
        print ID,pos,allele0,allele1,"| HMERF: "," ".join(v for v in positions[int(pos)][1])
        seen.add(int(pos))
        indices[linenum] = ([allele0,allele1],positions[int(pos)][0])
   

infile.close()
outlegend.close()

missing=[]
print "=============================\nMissing in 1K"
print "-----------------------------"

for k,v in positions.iteritems():
    if k not in seen:
        missing.append(positions[k])
        print " ".join(b for b in v[1])

seen.add(179410829)
pos = [s for s in seen]
pos.sort()
print pos

for p in pos:
    if p in seen:
        outHMERF.write(",".join(v for v in positions[p][1])+"\n")

outHMERF.close()

missing=sorted(missing)
print "============================="
# now lets try to filter the data
infile = open("impute1K.impute.hap")
outfile = open("match1K","w")
for index,line in enumerate(infile):
    if index in indices:
        b = line.strip().split()
        code =   indices[index][0]
        outfile.write(" ".join(code[int(a)] for a in b)+"\n")

outfile.close()
infile.close()
```

Convert the last code into R functions


```{r extract_positionsr}
library(data.table)
library(pander)
data_hmerf <- fread("HMERF_Haplotype.csv")
setkey(data_hmerf, position)
data_1K <- fread("tmpfiles/impute1K1.impute.legend")
setkey(data_1K, pos)
matching_positions <- data_hmerf[data_1K, nomatch=0]
fwrite(matching_positions, file = "tmpfiles/HMERFmatch1K.csv")

d <- rbind(matching_positions, data_hmerf[position==179410829], fill=TRUE)
setkey(d, position)

fwrite(
  matching_positions[,.(ID, pos=position, allele0, allele1)],
  file="tmpfiles/match1K.legend"
)

pander(matching_positions, caption="Present in HMERF and 1K", split.table=Inf)

missing <- data_hmerf[!(position %in% data_1K$pos)]
pander(data.table(missing), caption="Present in HMERF and missing in 1K Genomes")



seen.add(179410829)
pos = [s for s in seen]
pos.sort()
print pos

for p in pos:
    if p in seen:
        outHMERF.write(",".join(v for v in positions[p][1])+"\n")

outHMERF.close()

missing=sorted(missing)
print "============================="
# now lets try to filter the data
infile = open("impute1K.impute.hap")
outfile = open("match1K","w")
for index,line in enumerate(infile):
    if index in indices:
        b = line.strip().split()
        code =   indices[index][0]
        outfile.write(" ".join(code[int(a)] for a in b)+"\n")

outfile.close()
infile.close()
```



### Prepare data for PHASE


```{r transform_input_for_phase}
source("Transform_PHASE.R")
```
We now have 

### Run PHASE

```{r runphase, cache=TRUE}
system2("PHASE",args=c("-kphase1K.known","phase1K.inp","phase1K.out"), stdout = "phase.stdout", stderr = "phase.stderr")
```

### Load the results

```{r load_results}
source("read_phase_functions.R")
# Read the pairs output.  We have columns
pairs <- readpairs("phase1K.out_pairs")
colnames(pairs) <- c("name", "hap1", "hap2", "pprob")
## These are all the pairs, we need to extract our hmerf samples
hmerf_samples <- colnames(hmerf)[-c(1:2)]
hmerf_pairs <- pairs[pairs$name %in% hmerf_samples,]
control_pairs <- pairs[!(pairs$name %in% hmerf_samples),]
## These pairs all have the same posterior probalility - which
## is just as well as they are all supposed to be phased.
## Get raw data
raw <- t(as.matrix(read.table("match1K", stringsAsFactors = FALSE)))

## Split the phased output.



```
